#!/usr/bin/env ruby

require 'fileutils'
require 'optparse'
require 'jkr'

def ul(str)
  "\033[4m#{str}\033[24m"
end

def identity

end

class JkrCmd
  def jkr_commands()
    self.methods.map{|method_sym|
      if method_sym.to_s =~ /^([a-z_-]+)_cmd$/
        $~[1]
      else
        nil
      end
    }.compact
  end

  def setup_optparser()
    @optparser = OptionParser.new

    @optparser.banner = <<EOS
Usage: #{$0} [#{ul('command')} [#{ul('options')}]]

Available commands: #{self.jkr_commands.join(', ')}

'#{$0} help #{ul('command')}' shows detailed usage of #{ul('command')}

EOS

    @options[:directory] = Dir.pwd
    @options[:jkr_directory] = File.join(@options[:directory], "jkr")

    @optparser.on('-C', '--directory DIR',
               "Change to directory DIR before reading jkr config files."
               ) do |directory|
      @options[:directory] = directory
      @options[:jkr_directory] = File.join(@options[:directory], "jkr")
    end

    @optparser.on('-f', '--jkr-directory DIR',
                  "Jkr specification file."
                  ) do |jkr_directory|
      @options[:jkr_directory] = jkr_directory
    end
  end

  def parse_args(argv)
    @optparser.parse!(argv)
    @options
  end

  def initialize()
    @options = Hash.new
    self.setup_optparser()
  end

  def dispatch(argv)
    self.parse_args(argv) # argv updated destructively

    if argv.empty?
      argv = ["run"]
    end
    command = argv.shift
    unless self.jkr_commands.include?(command)
      $stderr.puts "No such command: #{command}"
      puts
      puts @optparser.help
      exit 1
    end

    self.send("#{command}_cmd", argv)
    true
  end

  ## Command definitions

  def analyze_cmd(argv)
    @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

    argv.each do |arg|
      Jkr::Analysis.analyze(@jkr_env, arg)
    end
  end

  def analyze_cmd_help()
     {
       :summary => "analyze results",
       :desc => "Usage: #{$0} analyze #{ul('RESULT_ID')} ..."
     }
   end

   def list_cmd(argv)
     @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

     puts "Existing plans:"
     puts
     plans = @jkr_env.plans.map do |plan_file_path|
       plan = Jkr::Plan.new(@jkr_env, plan_file_path)
       [File.basename(plan_file_path, ".plan"), plan.title]
     end
     maxlen = plans.map{|plan| plan[0].size}.max
     plans.each do |plan|
       printf(" %#{maxlen}s : %s\n", plan[0], plan[1])
     end
     puts
   end
   def list_cmd_help()
     {
       :summary => "list existing plans",
       :desc => "list existing plans"
     }
   end

   def run_cmd(argv)
     @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

     @jkr_env.plans.each do |plan_file_path|
       if File.basename(plan_file_path) == argv.first + ".plan"
         plan = Jkr::Plan.new(@jkr_env, plan_file_path)
         Jkr::Trial.run(@jkr_env, plan)
       end
     end
   end

   def run_cmd_help()
     {
       :summary => "run experiments",
       :desc => ""
     }
   end

   def init_cmd(argv)
     jkr_dir = File.join(@options[:directory], "jkr")
     result_dir = File.join(@options[:directory], "jkr", "result")
     plan_dir = File.join(@options[:directory], "jkr", "plan")
     script_dir = File.join(@options[:directory], "jkr", "script")
     queue_dir = File.join(@options[:directory], "jkr", "queue")
     [jkr_dir,
      result_dir,
      plan_dir,
      script_dir,
      queue_dir].each{|dir| FileUtils.mkdir(dir) }
     File.open(File.join(plan_dir, "example.plan.sample"), "w") do |file|
       file.puts <<EOSS
 # -*- mode: ruby -*-

title "example"
description "this is an example."

def_parameters do
  constant :foo => 123
end

def_prep do |plan|
end

def_routine do |plan, params|
  # do nothing
end

def_cleanup do |plan|
end

def_analysis do |plan|
end
EOSS
     end
   end
   def install_cmd_help()
     {
       :summary => "install jkr skelton setting files",
       :desc => ""
     }
   end

   def help_cmd(argv)
     case argv[0]
     when /^commands/
       commands = self.jkr_commands
       puts "Available commands:"
       max_len = commands.map(&:size).max
       commands.each do |command|
         help = self.send("#{command}_cmd_help")
         printf "  %#{max_len}s : #{help[:summary]}\n", command
       end
       puts
     else
       commands = argv.select{|arg| self.jkr_commands.include?(arg)}
       if commands.size > 0
         commands.each do |cmd|
           help = self.send("#{cmd}_cmd_help")
           puts("== help: #{cmd} ==\n#{help[:summary]}\n\n#{help[:desc]}\n")
        end
      else
        puts @optparser.help
      end
    end
  end
  def help_cmd_help()
    {
      :summary => "show helps",
      :desc => ""
    }
  end

end

def main(argv)
  exit(JkrCmd.new.dispatch(argv))
end

if __FILE__ == $0 || $0 =~ /ruby-prof$/
  main(ARGV.dup)
else
  p $0
  p ARGV
end

