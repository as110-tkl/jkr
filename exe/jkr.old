#!/usr/bin/env ruby

require 'fileutils'
require 'optparse'
require 'jkr'

def ul(str)
  "\033[4m#{str}\033[24m"
end

def identity

end

class JkrCmd
  class DirLock
    def self.lock(dir_path)
      File.open(File.expand_path('.lock', dir_path),
                File::RDWR | File::CREAT) do |f|
        f.flock(File::LOCK_EX)
        yield
      end
    end
  end

  def jkr_commands()
    self.methods.map{|method_sym|
      if method_sym.to_s =~ /^([a-z_-]+)_cmd$/
        $~[1]
      else
        nil
      end
    }.compact
  end

  def setup_optparser()
    @optparser = OptionParser.new

    @optparser.banner = <<EOS
Usage: #{$0} [#{ul('command')} [#{ul('options')}]]

Available commands: #{self.jkr_commands.join(', ')}

'#{$0} help #{ul('command')}' shows detailed usage of #{ul('command')}

EOS

    @options[:directory] = Dir.pwd
    @options[:jkr_directory] = File.join(@options[:directory], "jkr")
    @options[:delete_files_on_error] = true

    @optparser.on('-C', '--directory DIR',
               "Change to directory DIR before reading jkr config files."
               ) do |directory|
      @options[:directory] = directory
      @options[:jkr_directory] = File.join(@options[:directory], "jkr")
    end

    @optparser.on('-f', '--jkr-directory DIR',
                  "Jkr specification file."
                  ) do |jkr_directory|
      @options[:jkr_directory] = jkr_directory
    end

    @optparser.on('-D', '--debug',
                  'Do not remove result files even if error happened for debugging.') do
      @options[:delete_files_on_error] = false
    end
  end

  def parse_args(argv)
    @optparser.parse!(argv)
    @options
  end

  def initialize()
    @options = Hash.new
    self.setup_optparser()
  end

  def dispatch(argv)
    self.parse_args(argv) # argv updated destructively

    if argv.empty?
      puts @optparser.help
      exit 1
    end

    command = argv.shift
    unless self.jkr_commands.include?(command)
      $stderr.puts "No such command: #{command}"
      puts
      puts @optparser.help
      exit 1
    end

    self.send("#{command}_cmd", argv)
    true
  end

  ## Command definitions

  def analyze_cmd(argv)
    @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

    argv.each do |arg|
      Jkr::Analysis.analyze(@jkr_env, arg)
    end
  end

  def analyze_cmd_help()
     {
       :summary => "analyze results",
       :desc => "Usage: #{$0} analyze #{ul('RESULT_ID')} ..."
     }
   end

   def list_cmd(argv)
     @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

     puts "Existing plans:"
     puts
     plans = @jkr_env.plans.map do |plan_file_path|
       plan = Jkr::Plan.new(@jkr_env, nil, :plan_path => plan_file_path)
       [File.basename(plan_file_path, ".plan"), plan.title]
     end
     maxlen = plans.map{|plan| plan[0].size}.max
     plans.each do |plan|
       printf(" %#{maxlen}s : %s\n", plan[0], plan[1])
     end
     puts
   end
   def list_cmd_help()
     {
       :summary => "list existing plans",
       :desc => "list existing plans"
     }
   end

   def pretty_time(seconds)
     hour = seconds / 3600
     min = (seconds - hour * 3600) / 60
     sec = seconds - hour * 3600 - min * 60

     sprintf("%02d:%02d:%02d", hour, min, sec)
   end

   def find_plan_file(plan_name)
     @jkr_env.plans.find do |plan_file_path|
       File.basename(plan_file_path) == plan_name + ".plan"
     end
   end

   def run_cmd(argv)
     @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

     if ! argv.empty?
       plan_name = argv.first
       plan_file = find_plan_file(plan_name)

       unless plan_file
         raise ArgumentError.new("No such plan: #{plan_name}")
       end

       plan = Jkr::Plan.new(@jkr_env, nil, :plan_path => plan_file)
       Jkr::Trial.run(@jkr_env, plan, @options[:delete_files_on_error])
     end


     # run queued plans

     # show estimated execution time first
     queued_plans = Dir.glob(File.expand_path('*.plan', @jkr_env.jkr_queue_dir))

     if queued_plans.size > 0
       puts("")
       puts("== Execution time estimates ==")
       total_time = 0
       queued_plans.each do |plan_path|
         plan = Jkr::Plan.new(@jkr_env, nil, :plan_path => plan_path)
         if plan.exec_time_estimate
           time_sec = plan.exec_time_estimate.call(plan)
           time = pretty_time(time_sec)
         else
           total_time = nil
           time = "N/A"
         end

         if total_time
           total_time += time_sec
         end

         puts("  * #{File.basename(plan_path)}:\t#{time}")
       end
       puts("")
       if total_time
         puts("  * Total: #{pretty_time(total_time)}")
       else
         puts("  * Total: N/A")
       end
       puts("")
     end

     process_queue = true
     while process_queue
       Dir.mktmpdir do |tmpdir|
         plan_file = nil

         DirLock.lock(@jkr_env.jkr_queue_dir) do
           queued_plans = Dir.glob(File.expand_path('*.plan',
                                                    @jkr_env.jkr_queue_dir))
           if queued_plans.empty?
             process_queue = false
             break
           end

           queued_plan = queued_plans.sort.first
           plan_file = File.expand_path(File.basename(queued_plan).gsub(/\A\d{5}\./, ''), tmpdir)
           FileUtils.copy(queued_plan, plan_file)
           FileUtils.remove(queued_plan)
         end
         break unless process_queue

         plan = Jkr::Plan.new(@jkr_env, nil, :plan_path => plan_file)
         Jkr::Trial.run(@jkr_env, plan, @options[:delete_files_on_error])
       end
     end
   end

   def run_cmd_help()
     {
       :summary => "run experiments",
       :desc => ""
     }
   end

   def queue_cmd(argv)
     @jkr_env = Jkr::Env.new(@options[:directory], @options[:jkr_directory])

     DirLock.lock(@jkr_env.jkr_queue_dir) do
       queue_ids = Dir.glob(File.expand_path('*.plan', @jkr_env.jkr_queue_dir)).map do |plan_file|
         if File.basename(plan_file) =~ /\A(\d{5})\./
           $~[1].to_i
         else
           nil
         end
       end.compact
       next_queue_id = ([-1] + queue_ids).max + 1


       plan_name = argv.first
       plan_file = find_plan_file(plan_name)

       unless plan_file
         raise ArgumentError.new("No such plan: #{plan_name}")
       end

       FileUtils.copy(plan_file,
                      File.expand_path(sprintf("%05d.%s", next_queue_id,
                                               File.basename(plan_file)),
                                       @jkr_env.jkr_queue_dir))
     end
   end

   def queue_cmd_help()
     {
       :summary => "queue experiment plan",
       :desc => ""
     }
   end

   def init_cmd(argv)
     jkr_dir = File.join(@options[:directory], "jkr")
     result_dir = File.join(@options[:directory], "jkr", "result")
     plan_dir = File.join(@options[:directory], "jkr", "plan")
     script_dir = File.join(@options[:directory], "jkr", "script")
     queue_dir = File.join(@options[:directory], "jkr", "queue")
     [jkr_dir,
      result_dir,
      plan_dir,
      script_dir,
      queue_dir].each{|dir| FileUtils.mkdir(dir) }
     [result_dir, plan_dir, script_dir, queue_dir].each do |dir|
       File.open(File.expand_path(".gitdir", dir), "w") do |_|
       end
     end
     File.open(File.join(plan_dir, "example.plan.sample"), "w") do |file|
       file.puts <<EOSS
 # -*- mode: ruby -*-

title "example"
description "this is an example."
short_desc ""

def_parameters do
  constant :foo => 123
  variable :trial_no => [1,2,3]
end

def_prep do |plan|
end

# This is optional routine for presenting estimated execution time for users.
# Return estimated execution time in seconds.
exec_time_estimate do |plan|
  # 30 seconds for each trial
  30 * plan.vars[:trial_no].size
end

def_routine do |plan, params|
  # store various information with metastore
  # metastore data is saved in "metastore.msh" with Marshal.dump for each trial
  plan.metastore[:foo] = "bar"
end

def_cleanup do |plan|
end

def_analysis do |plan|
end
EOSS
     end
   end
   def install_cmd_help()
     {
       :summary => "install jkr skelton setting files",
       :desc => ""
     }
   end

   def help_cmd(argv)
     case argv[0]
     when /^commands/
       commands = self.jkr_commands
       puts "Available commands:"
       max_len = commands.map(&:size).max
       commands.each do |command|
         help = self.send("#{command}_cmd_help")
         printf "  %#{max_len}s : #{help[:summary]}\n", command
       end
       puts
     else
       commands = argv.select{|arg| self.jkr_commands.include?(arg)}
       if commands.size > 0
         commands.each do |cmd|
           help = self.send("#{cmd}_cmd_help")
           puts("== help: #{cmd} ==\n#{help[:summary]}\n\n#{help[:desc]}\n")
        end
      else
        puts @optparser.help
      end
    end
  end
  def help_cmd_help()
    {
      :summary => "show helps",
      :desc => ""
    }
  end

end

def main(argv)
  exit(JkrCmd.new.dispatch(argv))
end

main(ARGV.dup)
